# core/telegram_service.py
import asyncio
import logging
from typing import Optional, Dict, Any
from telegram import Bot, Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application, CommandHandler, CallbackQueryHandler, MessageHandler, filters
)
from django.conf import settings
from asgiref.sync import sync_to_async
from .models import Driver, Booking

logger = logging.getLogger(__name__)


class TelegramBotService:
    """Service to manage interactions with Telegram"""

    def __init__(self):
        self.token = settings.TELEGRAM_BOT_TOKEN
        self.bot = Bot(token=self.token)
        self.application = None

    async def initialize_application(self):
        """Initializes the Telegram application"""
        if not self.application:
            self.application = Application.builder().token(self.token).build()

            # Add the handlers
            self.application.add_handler(CommandHandler("start", self.start_command))
            self.application.add_handler(CommandHandler("help", self.help_command))
            self.application.add_handler(CommandHandler("status", self.status_command))
            self.application.add_handler(CallbackQueryHandler(self.handle_booking_response, pattern="^booking_"))
            self.application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, self.handle_message))

    async def start_command(self, update: Update, context):
        """Commande /start"""
        chat_id = update.effective_chat.id
        username = update.effective_user.username

        welcome_message = f"""
üöñ *Bienvenue sur French Driver !*

Bonjour ! Je suis le bot officiel pour les chauffeurs VTC.

Pour recevoir des notifications de courses, vous devez √™tre enregistr√© dans notre syst√®me avec votre Chat ID : `{chat_id}`

üìã *Commandes disponibles :*
/help - Afficher cette aide
/status - V√©rifier votre statut

üí° *Comment √ßa marche :*
1. Votre dispatcher vous enregistre avec ce Chat ID
2. Vous recevez des notifications de nouvelles courses
3. Vous pouvez accepter ou refuser directement ici

‚ùì Pour toute question, contactez votre dispatcheur.
        """

        await update.message.reply_text(
            welcome_message,
            parse_mode='Markdown'
        )

        # Log for the dispatcher
        logger.info(f"Nouveau chauffeur Telegram: Chat ID {chat_id}, Username: @{username}")

    async def help_command(self, update: Update, context):
        """Commande /help"""
        help_message = """
üÜò *Aide French Driver Bot*

üìã *Commandes :*
/start - D√©marrer et obtenir votre Chat ID
/help - Afficher cette aide
/status - V√©rifier votre statut dans le syst√®me

üîî *Notifications :*
- Vous recevez automatiquement les nouvelles courses
- Utilisez les boutons pour accepter/refuser
- R√©ponse rapide = plus de courses !

‚öôÔ∏è *Configuration :*
Pour activer les notifications, donnez ce Chat ID √† votre dispatcheur :
`{}`

üìû *Support :*
Contactez votre centrale pour tout probl√®me technique.
        """.format(update.effective_chat.id)

        await update.message.reply_text(help_message, parse_mode='Markdown')

    async def status_command(self, update: Update, context):
        """Commande /status"""
        chat_id = str(update.effective_chat.id)

        try:
            # Search driver by chat_id
            driver = await sync_to_async(Driver.objects.get)(telegram_chat_id=chat_id)

            status_message = f"""
‚úÖ *Statut : CONNECT√â*

üë§ *Informations :*
- Nom : {driver.name}
- Licence : {driver.license_number}
- V√©hicule : {driver.get_vehicle_summary()}

üîî *Notifications :*
- Statut : {'‚úÖ Activ√©es' if driver.notifications_enabled else '‚ùå D√©sactiv√©es'}
- Chat ID : `{chat_id}`

üìä *Statistiques :*
- Courses totales : {await sync_to_async(driver.bookings.count)()}
- Courses en cours : {await sync_to_async(driver.bookings.filter(status__in=['DRIVER_ASSIGNED', 'IN_PROGRESS']).count)()}
            """

        except Driver.DoesNotExist:
            status_message = f"""
‚ùå *Statut : NON CONNECT√â*

Votre Chat ID `{chat_id}` n'est pas enregistr√© dans notre syst√®me.

üìù *Pour vous connecter :*
1. Donnez ce Chat ID √† votre dispatcheur
2. Il vous enregistrera dans le syst√®me
3. Vous recevrez une confirmation

üí° *Besoin d'aide ?*
Contactez votre centrale avec ce Chat ID.
            """

        await update.message.reply_text(status_message, parse_mode='Markdown')

    async def handle_message(self, update: Update, context):
        """G√©rer les messages texte g√©n√©riques"""
        await update.message.reply_text(
            "ü§ñ Utilisez les commandes /start, /help ou /status pour interagir avec le bot."
        )

    async def send_booking_notification(self, driver: Driver, booking: Booking) -> bool:
        """Envoie une notification de nouvelle course"""
        if not driver.can_receive_notifications():
            return False

        try:
            # Create the action buttons
            keyboard = [
                [
                    InlineKeyboardButton("‚úÖ Accepter", callback_data=f"booking_accept_{booking.id}"),
                    InlineKeyboardButton("‚ùå Refuser", callback_data=f"booking_refuse_{booking.id}")
                ],
                [
                    InlineKeyboardButton("üìç Voir itin√©raire", callback_data=f"booking_route_{booking.id}")
                ]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)

            # Notification message
            message = f"""
üöñ *NOUVELLE COURSE DISPONIBLE*

üìç *D√©part :* {booking.pickup_address}
üéØ *Destination :* {booking.destination_address}
‚è∞ *Heure pr√©vue :* {booking.scheduled_time.strftime('%d/%m/%Y √† %H:%M')}
üí∞ *Prix estim√© :* {booking.estimated_price}‚Ç¨

üë§ *Client :* {booking.user.get_full_name() or booking.user.username}
üì± *Contact :* {booking.user.phone_number or 'Non renseign√©'}

üîî *R√©pondez rapidement pour augmenter vos chances !*
            """

            await self.bot.send_message(
                chat_id=driver.telegram_chat_id,
                text=message,
                parse_mode='Markdown',
                reply_markup=reply_markup
            )

            return True

        except Exception as e:
            logger.error(f"Erreur envoi notification Telegram √† {driver.name}: {e}")
            return False

    async def handle_booking_response(self, update: Update, context):
        """G√©rer les r√©ponses aux notifications de courses"""
        query = update.callback_query
        await query.answer()

        data = query.data
        chat_id = str(query.effective_chat.id)

        try:
            # Check that the driver exists
            driver = await sync_to_async(Driver.objects.get)(telegram_chat_id=chat_id)

            if data.startswith("booking_accept_"):
                booking_id = int(data.split("_")[2])
                await self.handle_booking_accept(query, driver, booking_id)

            elif data.startswith("booking_refuse_"):
                booking_id = int(data.split("_")[2])
                await self.handle_booking_refuse(query, driver, booking_id)

            elif data.startswith("booking_route_"):
                booking_id = int(data.split("_")[2])
                await self.handle_route_request(query, driver, booking_id)

        except Driver.DoesNotExist:
            await query.edit_message_text(
                "‚ùå Erreur : Vous n'√™tes pas enregistr√© dans le syst√®me."
            )
        except Exception as e:
            logger.error(f"Erreur traitement r√©ponse Telegram: {e}")
            await query.edit_message_text(
                "‚ùå Erreur lors du traitement de votre r√©ponse."
            )

    async def handle_booking_accept(self, query, driver: Driver, booking_id: int):
        """G√©rer l'acceptation d'une course"""
        try:
            booking = await sync_to_async(Booking.objects.get)(id=booking_id)

            if booking.status != 'PENDING':
                await query.edit_message_text(
                    "‚ùå Cette course n'est plus disponible."
                )
                return

            # Assign the driver (this will be managed on the admin side)
            response_message = f"""
‚úÖ *COURSE ACCEPT√âE*

Merci {driver.name} ! Votre acceptation a √©t√© transmise √† la centrale.

üìã *D√©tails :*
- Course #{booking.confirmation_number}
- D√©part : {booking.pickup_address}
- Destination : {booking.destination_address}
- Prix : {booking.estimated_price}‚Ç¨

‚è≥ *Prochaines √©tapes :*
1. La centrale va confirmer votre assignation
2. Vous recevrez les coordonn√©es client
3. Contactez le client si n√©cessaire

üöó *Bonne course !*
            """

            await query.edit_message_text(response_message, parse_mode='Markdown')

            # Log for the dispatcher
            logger.info(f"Course {booking_id} accept√©e par {driver.name} (Telegram)")

        except Booking.DoesNotExist:
            await query.edit_message_text("‚ùå Course introuvable.")

    async def handle_booking_refuse(self, query, driver: Driver, booking_id: int):
        """G√©rer le refus d'une course"""
        await query.edit_message_text(
            f"‚ùå Course refus√©e par {driver.name}.\n\n"
            "La course reste disponible pour d'autres chauffeurs."
        )

        logger.info(f"Course {booking_id} refus√©e par {driver.name} (Telegram)")

    async def handle_route_request(self, query, driver: Driver, booking_id: int):
        """G√©rer la demande d'itin√©raire"""
        try:
            booking = await sync_to_async(Booking.objects.get)(id=booking_id)

            # Create a Google Maps link
            google_maps_url = (
                f"https://www.google.com/maps/dir/"
                f"{booking.pickup_latitude},{booking.pickup_longitude}/"
                f"{booking.destination_latitude},{booking.destination_longitude}"
            )

            route_message = f"""
üó∫Ô∏è *ITIN√âRAIRE*

üìç *D√©part :* {booking.pickup_address}
üéØ *Destination :* {booking.destination_address}

üîó [Ouvrir dans Google Maps]({google_maps_url})

üí° *Conseil :* V√©rifiez le trafic avant d'accepter !
            """

            # Add the original action buttons
            keyboard = [
                [
                    InlineKeyboardButton("‚úÖ Accepter", callback_data=f"booking_accept_{booking.id}"),
                    InlineKeyboardButton("‚ùå Refuser", callback_data=f"booking_refuse_{booking.id}")
                ]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)

            await query.edit_message_text(
                route_message,
                parse_mode='Markdown',
                reply_markup=reply_markup,
                disable_web_page_preview=True
            )

        except Booking.DoesNotExist:
            await query.edit_message_text("‚ùå Course introuvable.")


# Global instance of the service
telegram_service = TelegramBotService()
